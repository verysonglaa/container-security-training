<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Container Security Training</title><link>/</link><description>Recent content on Container Security Training</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Images</title><link>/docs/container-basics/01-basics/01/_images/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_images/</guid><description>Docker images You can search for images available on Docker Hub by clicking the Explore link or by typing mariadb into the search field: https://hub.docker.com/search/?q=mariadb&amp;type=image You will get a list of results and the first hit will probably be the official image: https://hub.docker.com/_/mariadb This page contains instructions on how to pull the image. Let&amp;rsquo;s pull a certain version of mariadb:
docker pull mariadb:11.5 Security Best Practices When using images from Docker Hub or other sources, always follow these practices:</description></item><item><title>Environment variables</title><link>/docs/container-basics/01-basics/01/_env-vars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_env-vars/</guid><description>Why was there an error in the previous lab?
The MariaDB server cannot run without a proper configuration. Docker can pass configuration variables into the setup process via environment variables. Environment variables are passed with the -e parameter, as in:
docker run -it -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb After running the command, you will see output similar to this:
Initializing database PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER! To do so, start the server, then issue the following commands: &amp;#39;/usr/bin/mysqladmin&amp;#39; -u root password &amp;#39;new-password&amp;#39; &amp;#39;/usr/bin/mysqladmin&amp;#39; -u root -h &amp;lt;host&amp;gt; password &amp;#39;new-password&amp;#39; Alternatively, you can run: &amp;#39;/usr/bin/mysql_secure_installation&amp;#39; Notice that we used the arguments -it (interactive terminal).</description></item><item><title>Frontend</title><link>/docs/container-basics/01-basics/01/_frontend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_frontend/</guid><description>Frontend Let&amp;rsquo;s create a frontend to demonstrate port-forwarding and container connections. We will run a simple Python web server that displays all users in our MariaDB.
First, get the IP of the currently running MariaDB container. By default, all containers are started in the bridge network, where no DNS service is available, so we can&amp;rsquo;t use container names. As a workaround, we use the IP of the container:
export ip=$(docker inspect mariadb-container-with-external-volume -f &amp;#39;{{ range.</description></item><item><title>Dockerfile</title><link>/docs/container-basics/01-basics/01/_dockerfile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_dockerfile/</guid><description>Dockerfile Docker builds container images by reading instructions from a &amp;lsquo;Dockerfile&amp;rsquo; or, more broadly, a &amp;lsquo;Containerfile.&amp;rsquo;&amp;quot; The basic docs on how Dockerfiles work can be found at https://docs.docker.com/engine/reference/builder/ .
Write your first Dockerfile Let us have a general look at how to build a container image. For that, create a new directory with an empty Dockerfile in there.
mkdir myfirstimage cd myfirstimage touch Dockerfile Open Dockerfile in your preferred text editor and add the following instructions:</description></item><item><title>MultiStage Build</title><link>/docs/container-basics/01-basics/01/_dockerfile_ms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_dockerfile_ms/</guid><description>Often you&amp;rsquo;re going to use some kind of libraries, tools or dependencies during the build phase of your application that are not necessary during the runtime of the container. To improve security and efficiency we only include whats absolutely necessary in the image. So we often remove these dependencies in the build phase after the application itself has been built.
In this lab you&amp;rsquo;re going to learn how to use multistage builds and what they are good for.</description></item><item><title>Under the hood</title><link>/docs/container-basics/01-basics/01/_deepdive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_deepdive/</guid><description>A closer look at the docker command and the runtime We&amp;rsquo;ve learned that the term &amp;ldquo;Docker&amp;rdquo; is used somewhat imprecisely. It refers to various components such as the CLI (Command Line Interface), the Docker Engine, the OCI image format, and the Container runtime. Let&amp;rsquo;s take a closer look at what&amp;rsquo;s happening when we use the command:
docker run --rm -d --name sleep-container alpine sleep 900 We will see the meaning of -rm and the other arguments later.</description></item><item><title>SSDLC</title><link>/docs/container-basics/02-security/02/_ssdlc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_ssdlc/</guid><description>Secure Software Development Lifecycle Docker security covers the entire lifecycle of containers, including their runtime, build process, and orchestration. Key security areas include base images, Dockerfiles, container runtimes, and securing the Docker daemon. Additionally, it&amp;rsquo;s important to configure container isolation, manage user privileges effectively, and follow security best practices when orchestrating containers at scale.
To ensure we fully understand and manage our workload, it&amp;rsquo;s crucial to focus on our Software Development Lifecycle (SDLC).</description></item><item><title>Docker Trust</title><link>/docs/container-basics/02-security/02/_trust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_trust/</guid><description>This lab focuses on understanding and securing image distribution. We&amp;rsquo;ll start with a simple docker pull and build up to using Docker Content Trust (DCT).
Let us start with a common pull
docker pull alpine:edge This command will pull the Alpine image tagged as edge. The corresponding image can be found here on Docker Store .
If no tag is specified, Docker will pull the image with the latest tag.</description></item><item><title>Avoid Root</title><link>/docs/container-basics/02-security/02/_root/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_root/</guid><description>Before exploring different options to minimize container privileges, it&amp;rsquo;s important to address a fundamental yet frequently overlooked practice: keeping your software up to date. Regular updates are crucial for protecting against known container escape vulnerabilities, such as Leaky Vessels , which often allow attackers to gain root access to the host. This means both the host system and Docker itself must be consistently updated, including the host kernel and Docker Engine.</description></item><item><title>Capabilities</title><link>/docs/container-basics/02-security/02/_capabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_capabilities/</guid><description>Understanding container capabilities Capabilities in Linux are fine-grained controls that are part of the POSIX permissions system. These capabilities allow you to limit or extend the privileges of a process. Container capabilities are a set of predefined permissions that control what operations a container can perform on the host system. By default, containers run with a wide set of capabilities, but in many cases, they do not require all of them, so giving them only the permissions they need makes them safer to use.</description></item><item><title>Volume security</title><link>/docs/container-basics/02-security/02/_volumes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_volumes/</guid><description>So far we configured user and process permissions of the container. Another important step is to check the filesystem permissions and mount options of a container.
A common method is to run the containers with a read-only filesystem. Let us try to write into a read-only mounted filesystem:
docker run --rm --read-only alpine sh -c &amp;#39;echo &amp;#34;whatever&amp;#34; &amp;gt; /tmp/blub&amp;#39; The command fails with an error:
sh: can&amp;#39;t create /tmp/blub: Read-only file system If you still need to write temporary files, we can do that using the --tmpfs, this will create a temporary in-memory filesystem which is gone as soon at the container is stopped.</description></item><item><title>Linux Security Modules</title><link>/docs/container-basics/02-security/02/_lsm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_lsm/</guid><description>Introduction to Linux Security Modules Linux Security Modules (LSMs) provide mechanisms for implementing various security policies in Linux. They help in enforcing access controls and secure applications by restricting their capabilities and interactions with the system. The most popular LSMs are:
Seccomp (Secure Computing Mode):
Seccomp provides a way to filter system calls that a process can make. Defining a list of allowed or disallowed system calls can minimize the attack surface of applications by reducing the risk of exploitation through system call vulnerabilities.</description></item><item><title>Container Runtime Security</title><link>/docs/container-basics/02-security/02/_runtime_sec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_runtime_sec/</guid><description>Do the following commands and read the outputs carefully:
whoami head -1 /etc/shadow Now do this:
docker run -v /etc:/host alpine sh -c &amp;#39;whoami;head -1 /host/shadow&amp;#39; Why can you suddenly read stuff that you shouldn&amp;rsquo;t be allowed to? Are containers not restricted? The answer lies in the architecture of Docker:
By default, the Docker Deamon runs in root mode without user namespaces enabled. This means we can mount anything from the host into our container and change it there too using the root user inside our container.</description></item><item><title>Privileged Containers</title><link>/docs/container-basics/02-security/02/_privileged-mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_privileged-mode/</guid><description>A note on privileged containers The &amp;ndash;privileged option in Docker is a special flag that gives the container full access to the host system. Itâ€™s much more powerful than simply assigning specific capabilities because it bypasses most of Docker&amp;rsquo;s built-in security restrictions and grants the container elevated permissions, similar to running as root on the host. Often times you will see it in tutorials for running Docker inside Docker or similar things.</description></item><item><title>Recap</title><link>/docs/container-basics/02-security/02/_recap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_recap/</guid><description>We saw how to run containers and how to secure them avoiding root, dropping capabilities, mounting filesystems read-only, and using Linux Security Modules such as seccomp. However it is important to say that because of the architecture of docker, anyone who can start a container has more privileges on the host.
It is still important to secure the Host Operating system and maybe to run a deamonless container technology like podname.</description></item></channel></rss>