<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes Security Training</title><link>/</link><description>Recent content on Kubernetes Security Training</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1 Images</title><link>/docs/container-basics/01-basics/01/_images/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_images/</guid><description>Docker images You can search for images available on Docker Hub by clicking the Explore link or by typing mariadb into the search field: https://hub.docker.com/search/?q=mariadb&amp;type=image You will get a list of results and the first hit will probably be the official image: https://hub.docker.com/_/mariadb This page contains instructions on how to pull the image. Let&amp;rsquo;s pull a certain version of mariadb:
docker pull mariadb:11.5 Note Care about security! Check the images before you run them.</description></item><item><title>1.2 Environment variables</title><link>/docs/container-basics/01-basics/01/_env-vars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_env-vars/</guid><description>Environment variables So why was there an error in the previous lab? The MariaDB server is not able to run without a proper configuration. Docker can pass variables into the instantiation process via environment variables. Environment variables are passed via the parameter -e, e.g.:
docker run -it -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb Once you run the command you will see an output like this:
Initializing database PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !</description></item><item><title>1.3 Frontend</title><link>/docs/container-basics/01-basics/01/_frontend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_frontend/</guid><description>Frontend Let us create a frontend to showcase port-forwarding and the connection between containers. We will run a simple python webserver which display all the users in our mariadb.
First get the IP of the currently running mariadb container. By default all container are started in the bridge network, where no DNS service is available and we can&amp;rsquo;t use container name. As a workaround we use the IP of the container:</description></item><item><title>1.4 Dockerfile</title><link>/docs/container-basics/01-basics/01/_dockerfile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_dockerfile/</guid><description>Dockerfile Docker can build container images by reading the instructions on how to build the image from a so-called Dockerfile or more generally, Containerfile. The basic docs on how Dockerfiles work can be found at https://docs.docker.com/engine/reference/builder/ .
Write your first Dockerfile Let us have a general look at how to build a container image. For that, create a new directory with an empty Dockerfile in there.
mkdir myfirstimage cd myfirstimage Create a new File with the name Dockerfile and add the following content to that Dockerfile using your editor of choice:</description></item><item><title>1.5 MultiStage Build</title><link>/docs/container-basics/01-basics/01/_dockerfile_ms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_dockerfile_ms/</guid><description>Often you&amp;rsquo;re going to use some kind of libraries, tools or dependencies during the build phase of your application that are not necessary during the runtime of the container. To improve security and efficiency we only include whats absolutely necessary in the image. So we often remove these dependencies in the build phase after the application itself has been built.
In this lab you&amp;rsquo;re going to learn how to use multistage builds and what they are good for.</description></item><item><title>1.6 Under the hood</title><link>/docs/container-basics/01-basics/01/_deepdive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/01-basics/01/_deepdive/</guid><description>A closer look at the docker command and the runtime We&amp;rsquo;ve learned that the term &amp;ldquo;Docker&amp;rdquo; is used somewhat imprecisely. It&amp;rsquo;s employed to refer to various components such as the CLI (Command Line Interface), the Docker Engine, the OCI image format, and the Container runtime. Let&amp;rsquo;s take a closer look at what&amp;rsquo;s happening when we use the command
docker run --rm -d --name sleep-container alpine sleep 300 We will come to the meaning of -rm and the other arguments later on.</description></item><item><title>2.1 SSDLC</title><link>/docs/container-basics/02-security/02/_ssdlc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_ssdlc/</guid><description>Secure Software Development Lifecycle Docker security covers the entire lifecycle of containers, including their runtime, build process, and orchestration. Key security areas include base images, Dockerfiles, container runtimes, and securing the Docker daemon. Additionally, it&amp;rsquo;s important to configure container isolation, manage user privileges effectively, and follow security best practices when orchestrating containers at scale.
To ensure we fully understand and manage our workload, it&amp;rsquo;s crucial to focus on our Software Development Lifecycle (SDLC).</description></item><item><title>Docker/Container Security</title><link>/docs/container/container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container/container/</guid><description>Table of Contents Introduction Prerequisites Namespaces PID Namespace Network Namespace Mount Namespace Seccomp AppArmor SELinux Cgroups Additional Security Practices Conclusion Introduction In this lab, you will learn about various security mechanisms available in Docker and containers, including namespaces, seccomp, AppArmor, SELinux, and cgroups. You will also learn how containers communicate with the Linux kernel and how to secure this communication.
Prerequisites A system with Docker installed (preferably a Linux system) Basic knowledge of Docker and Linux commands Namespaces Namespaces are one of the fundamental building blocks of container isolation.</description></item><item><title>2.2 Avoid Root</title><link>/docs/container-basics/02-security/02/_root/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_root/</guid><description>Before exploring different options to minimize container privileges, it&amp;rsquo;s important to address a fundamental yet frequently overlooked practice: keeping your software up to date. Regular updates are crucial for protecting against known container escape vulnerabilities, such as Leaky Vessels , which often allow attackers to gain root access to the host. This means both the host system and Docker itself must be consistently updated, including the host kernel and Docker Engine.</description></item><item><title>2.3 Capabilities</title><link>/docs/container-basics/02-security/02/_capabilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_capabilities/</guid><description>Understanding Container Capabilities and How to Configure Them for Minimal Use Capabilities in Linux are fine-grained controls that are part of the POSIX permissions system. These capabilities allow you to limit or extend the privileges of a process. Container capabilities are a set of predefined permissions that control what operations a container can perform on the host system. By default, containers run with a wide set of capabilities, but in many cases, they do not require all of them, so giving them only the permissions they need makes them safer to use.</description></item><item><title>2.4 Volume security</title><link>/docs/container-basics/02-security/02/_volumes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_volumes/</guid><description>So far we configured user and process permissions of the container. Another important step is to check the filesystem permissions and mount options of a container.
A common method is to run the containers with a read-only filesystem. Please try the following:
docker run --rm --read-only alpine sh -c &amp;#39;echo &amp;#34;whatever&amp;#34; &amp;gt; /tmp/blub&amp;#39; The command fails with an error:
sh: can&amp;#39;t create /tmp/blub: Read-only file system If you still need to write temporary files, we can do that using the --tmpfs, this will create a temporary in-memory filesystem which is gone as soon at the container is stopped.</description></item><item><title>2.6 Linux Security Modules</title><link>/docs/container-basics/02-security/02/_seccomp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_seccomp/</guid><description>Introduction to Linux Security Modules Linux Security Modules (LSMs) provide mechanisms for implementing various security policies in Linux. They help in enforcing access controls and securing applications by restricting their capabilities and interactions with the system. The most populare LSMs are:
Seccomp (Secure Computing Mode):
Seccomp provides a way to filter system calls that a process can make. By defining a list of allowed or disallowed system calls, it can minimize the attack surface of applications by reducing the risk of exploitation through system call vulnerabilities.</description></item><item><title>2.6 Privileged Containers</title><link>/docs/container-basics/02-security/02/_privileged-mode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_privileged-mode/</guid><description>An note on privileged containers The &amp;ndash;privileged option in Docker is a special flag that gives the container full access to the host system. It’s much more powerful than simply assigning specific capabilities because it bypasses most of Docker&amp;rsquo;s built-in security restrictions and grants the container elevated permissions, similar to running as root on the host. Often times you will see it in tutorials for running Docker inside Docker or similar things.</description></item><item><title>2.7 Container Runtime Security</title><link>/docs/container-basics/02-security/02/_runtime_sec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/container-basics/02-security/02/_runtime_sec/</guid><description>TODO: Write about Docker Deamon running as root and how to change that.</description></item></channel></rss>