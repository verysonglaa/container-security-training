[{"body":"The command line tool First it is time to become familiar with the command line utility. Using Docker consists of passing at least one command. docker --help shows the available options:\ndocker --help Usage: docker COMMAND A self-sufficient runtime for containers Options: --config string Location of client config files (default \"/home/user/.docker\") -D, --debug Enable debug mode --help Print usage -H, --host list Daemon socket(s) to connect to -l, --log-level string Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\") --tls Use TLS; implied by --tlsverify --tlscacert string Trust certs signed only by this CA (default \"/home/user/.docker/ca.pem\") --tlscert string Path to TLS certificate file (default \"/home/user/.docker/cert.pem\") --tlskey string Path to TLS key file (default \"/home/user/.docker/key.pem\") --tlsverify Use TLS and verify the remote -v, --version Print version information and quit Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumes Commands: attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem events Get real time events from the server exec Run a command in a running container export Export a container's filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes Run 'docker COMMAND --help' for more information on a command. To view the switches available to a specific command, type:\ndocker \u003ccommand\u003e --help To view system-wide information about Docker, use:\ndocker info Hello world (with Docker images) Docker containers are run from Docker images. By default, they pull these images from Docker Hub, a Docker registry managed by Docker Inc, the company behind the Docker project. Anybody can build and host their Docker images on Docker Hub, so for many applications and Linux distributions you’ll find Docker images that are hosted on Docker Hub.\nTo check whether you can access and download images from Docker Hub, type:\ndocker run hello-world The output, which should include the following, indicates that Docker appears to be working correctly:\nHello from Docker. This message shows that your installation appears to be working correctly. ... Your first container 😃 With this command, we just ran our first container on our computers. It ran a simple process that printed a message to standard out, the container itself is not very useful though.\n","categories":"","description":"","excerpt":"The command line tool First it is time to become familiar with the …","ref":"/docs/container-basics/01-basics/","tags":"","title":"1. Docker Basics"},{"body":"Docker images You can search for images available on Docker Hub by clicking the Explore link or by typing mariadb into the search field: https://hub.docker.com/search/?q=mariadb\u0026type=image You will get a list of results and the first hit will probably be the official image: https://hub.docker.com/_/mariadb This page contains instructions on how to pull the image. Let’s pull a certain version of mariadb:\ndocker pull mariadb:11.5 Note Care about security! Check the images before you run them. Is it an official image ? Official Images are a good starting point, please read here why.\nWhat is installed in the image?\nRead the Dockerfile that was used to build the image Check the base image Check the vulnerabilitis of this image. Does it affect your application? Check the dependencies of the image. After an image has been downloaded, you may then run a container using the downloaded image with the sub-command run. If an image has not been downloaded when Docker is executed with the sub-command run, the Docker client will first download the image, then run a container using it:\ndocker run hello-world:linux Note Here we use the linux tag of the hello-world image instead of using latest again. To see the images that have been downloaded to your computer type:\ndocker images The output should look similar to the following:\nREPOSITORY TAG IMAGE ID CREATED SIZE mariadb 11.5 58730544b81b 2 weeks ago 397MB hello-world latest 1815c82652c0 2 months ago 1.84kB hello-world linux 1815c82652c0 2 months ago 1.84kB The hello world container you ran in the previous lab is an example of a container that runs and exits, after emitting a test message. Containers, however, can be much more useful than that, and they can be interactive. After all, they are similar to virtual machines, only more resource-friendly.\nAs an example, let’s run a container using the downloaded image of MariaDB. The combination of the -i and -t switches gives you interactive shell access to the container:\ndocker run -it mariadb:11.5 An error has popped up!\n2022-08-09 08:19:21+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:10.8.3+maria~jammy started. 2022-08-09 08:19:21+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql' 2022-08-09 08:19:21+00:00 [Note] [Entrypoint]: Entrypoint script for MariaDB Server 1:10.8.3+maria~jammy started. 2022-08-09 08:19:21+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD 🤔 Why do I get an error? Is this a bug in the image? Everything is fine, to run this image there is some configuration needed. Read the following excerpt carefully.\nerror: database is uninitialized and password option is not specified You need to specify one of MARIADB_ROOT_PASSWORD, MARIADB_ALLOW_EMPTY_ROOT_PASSWORD and MARIADB_RANDOM_ROOT_PASSWORD We will add the configuration later.\n🤔 What's an image? Think of an image like a blueprint of what will be in a container when it runs.\nAn image is a collection of files + some metadata (or in technical terms: those files form the root filesystem of a container) Images are made of layers, conceptually stacked on top of each other Each layer can add, change or remove files Images can share layers to optimize disk usage, transfer times and memory use You build these images using Dockerfiles (in later labs) Images are immutable, you cannot change them after creation 🤔 What's the difference between a container and an image? When you run an image, it becomes a container.\nAn image is a read-only filesystem A container is an encapsulated set of processes running in a read-write copy of that filesystem To optimize container boot time, copy-on-write is used instead of regular copy docker run starts a container from a given image ","categories":"","description":"","excerpt":"Docker images You can search for images available on Docker Hub by …","ref":"/docs/container-basics/01-basics/01/_images/","tags":"","title":"1.1 Images"},{"body":"\nKubernetes Security training!","categories":"","description":"","excerpt":"\nKubernetes Security training!","ref":"/docs/","tags":"","title":"Labs"},{"body":"Environment variables So why was there an error in the previous lab? The MariaDB server is not able to run without a proper configuration. Docker can pass variables into the instantiation process via environment variables. Environment variables are passed via the parameter -e, e.g.:\ndocker run -it -e MARIADB_ROOT_PASSWORD=my-secret-pw mariadb Once you run the command you will see an output like this:\nInitializing database PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER ! To do so, start the server, then issue the following commands: '/usr/bin/mysqladmin' -u root password 'new-password' '/usr/bin/mysqladmin' -u root -h password 'new-password' Alternatively you can run: '/usr/bin/mysql_secure_installation' which will also give you the option of removing the test databases and anonymous user created by default. This is strongly recommended for production servers. See the MariaDB Knowledgebase at http://mariadb.com/kb or the MySQL manual for more instructions. Please report any problems at http://mariadb.org/jira The latest information about MariaDB is available at http://mariadb.org/. You can find additional information about the MySQL part at: http://dev.mysql.com Consider joining MariaDB's strong and vibrant community: https://mariadb.org/get-involved/ Database initialized MySQL init process in progress... 2020-05-27 6:21:03 0 [Note] mysqld (mysqld 10.3.7-MariaDB-1:10.3.7+maria~jessie) starting as process 101 ... 2020-05-27 6:21:03 0 [Note] InnoDB: Using Linux native AIO 2020-05-27 6:21:03 0 [Note] InnoDB: Mutexes and rw_locks use GCC atomic builtins 2020-05-27 6:21:03 0 [Note] InnoDB: Uses event mutexes 2020-05-27 6:21:03 0 [Note] InnoDB: Compressed tables use zlib 1.2.8 2020-05-27 6:21:03 0 [Note] InnoDB: Number of pools: 1 2020-05-27 6:21:03 0 [Note] InnoDB: Using SSE2 crc32 instructions 2020-05-27 6:21:03 0 [Note] InnoDB: Initializing buffer pool, total size = 256M, instances = 1, chunk size = 128M ... 2020-05-27 6:21:08 0 [Note] mysqld: ready for connections. Version: '10.3.7-MariaDB-1:10.3.7+maria~jessie' socket: '/var/run/mysqld/mysqld.sock' port: 3306 mariadb.org binary distribution If you re-read the command above you will notify that we used the arguments -it (interactive/terminal). And you might have also found out that mariadb does not react to the usual CTRL-c. So how do we exit this terminal? Docker has an escape sequence to detach from a container and leave it running. For this you have to press CTRL-p and then CTRL-q in bash. In the webshell the shortcuts CTRL-p and CTRL-q are not working. Simply close the terminal and open a new one as a workaround.\nThis will leave the container running while you are back in your shell. To verify that the container is running use the following command:\ndocker ps The output should look much like this:\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7cb31f821233 mariadb \"docker-entrypoint...\" 5 minutes ago Up 5 minutes 3306/tcp upbeat_blackwell Access the container To connect to the container again you can use the following command:\ndocker exec -it \u003ccontainer\u003e bash Where \u003ccontainer\u003e can refer to the CONTAINER ID (the first two characters are normally sufficient) or one of the NAMES from the output of docker ps. In the above output this would be 7cb31f821233 or upbeat_blackwell.\nNote The docker exec command needs either the ID or NAME of the container. Additionally, at the end, an executable. In this example, it’s bash as we want to do something interactively in the container.\nOnce the command is executed you should see this:\nroot@7cb31f821233:/#\nNote Every time you connect yourself to a container you will always be the user that was defined in the Dockerfile. Now that we are connected, let’s find out if the MariaDB is working…\nmariadb -uroot -pmy-secret-pw If everything works as expected, you should now see the MariaDB command line:\nWelcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 8 Server version: 10.3.8-MariaDB-1:10.3.8+maria~jessie mariadb.org binary distribution Copyright (c) 2000, 2020, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u003e Type\nexit; to leave the mysql client. Type\nexit one more time to leave the container.\nDetached containers One might think: This whole starting process is a bit cumbersome with CTRL-p and then CTRL-q. Therefore, you can run a Docker container directly with -d (detached) mode, e.g.:\ndocker run -it -e MARIADB_ROOT_PASSWORD=my-secret-pw -d mariadb Instead of the output of the container itself, you will now only get the ID of the started container. If you have a look into the container list, you should see two running containers:\ndocker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 699e82ed8f1f mariadb \"docker-entrypoint...\" 3 minutes ago Up 3 minutes 3306/tcp jolly_bardeen 7cb31f821233 mariadb \"docker-entrypoint...\" 32 minutes ago Up 32 minutes 3306/tcp upbeat_blackwell We don’t need both of them running. To stop a container use the command:\ndocker stop \u003ccontainer\u003e After that, check the new state with\ndocker ps This should show only one container running:\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 699e82ed8f1f mariadb \"docker-entrypoint...\" 9 minutes ago Up 9 minutes 3306/tcp jolly_bardeen We just exited the container “gracefully”, but as an alternative you can also kill a container with the docker kill \u003ccontainer\u003e command. This stops the container immediately by using the KILL signal.\nYou may recognize that the container upbeat_blackwell is not present in the container list anymore. That is because docker ps only shows running containers, but as always you have a parameter that helps:\ndocker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 699e82ed8f1f mariadb \"docker-entrypoint...\" 12 minutes ago Up 12 minutes 3306/tcp jolly_bardeen 7cb31f821233 mariadb \"docker-entrypoint...\" 41 minutes ago Exited (0) 2 minutes ago upbeat_blackwell 67d79f95c712 hello-world \"/hello\" About an hour ago Exited (0) About an hour ago upbeat_boyd Now that the upbeat_blackwell container is stopped delete it:\ndocker rm \u003ccontainer\u003e Now the container has disappeared from the list:\ndocker ps --all CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 699e82ed8f1f mariadb \"docker-entrypoint...\" 13 minutes ago Up 13 minutes 3306/tcp jolly_bardeen 67d79f95c712 hello-world \"/hello\" About an hour ago Exited (0) About an hour ago upbeat_boyd It is a good idea to delete unused containers to save disk space and remove the data wich resides in the read/write layer of the container. So please delete the hello-word container too:\ndocker rm \u003ccontainer\u003e ","categories":"","description":"","excerpt":"Environment variables So why was there an error in the previous lab? …","ref":"/docs/container-basics/01-basics/01/_env-vars/","tags":"","title":"1.2 Environment variables"},{"body":" Kubernetes Security Basics Read more\nLab PDF Read more\n","categories":"","description":"","excerpt":" Kubernetes Security Basics Read more\nLab PDF Read more\n","ref":"/slides/","tags":"","title":"Slides"},{"body":"Dockerfile Docker can build container images by reading the instructions on how to build the image from a so-called Dockerfile or more generally, Containerfile. The basic docs on how Dockerfiles work can be found at https://docs.docker.com/engine/reference/builder/ .\nWrite your first Dockerfile Before we extend our php image we are going to have a more general look at how to build a container image. For that, create a new directory with an empty Dockerfile in there.\nmkdir myfirstimage cd myfirstimage Create a new File with the name Dockerfile and add the following content to that Dockerfile using your editor of choice:\nFROM ubuntu RUN apt-get update \u0026\u0026 \\ apt-get install -y figlet \u0026\u0026 \\ apt-get clean FROM indicates the base image for our build Each RUN line will be executed by Docker during the build Our RUN commands must be non-interactive (no input can be provided to Docker during the build) Check https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/ for further best practices on how to write Dockerfiles. Build the image Just run:\ndocker build -t myfirstimage . -t indicates the tag to apply to the image . indicates the location of the build context (which we will talk more about later, but is basically the directory where our Dockerfile is located) Please note that the tag can be omitted in most Docker commands and instructions. In that case, the tag defaults to latest. Besides being the default tag there’s nothing special about latest. Despite its name, it does not necessarily identify the latest version of an image.\nDepending on the build system it can point to the last image pushed, to the last image built from some branch, or to some old image. It can even not exist at all.\nBecause of this, you must never use the latest tag in production, always use a specific image version.\nAlso see: https://medium.com/@mccode/the-misunderstood-docker-tag-latest-af3babfd6375 What happens when we build the image The output of the Docker build looks like this:\nSending build context to Docker daemon 2.048kB Step 1/2 : FROM ubuntu ---\u003e ea4c82dcd15a Step 2/2 : RUN apt-get update \u0026\u0026 apt-get install -y figlet \u0026\u0026 apt-get clean ---\u003e b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest Sending the build context to Docker Sending build context to Docker daemon 84.48 kB ... The build context is the . directory given to docker build It is sent (as an archive) to the Docker daemon by the Docker client This allows you to use a remote machine to build using local files Be careful (or patient) if that directory is big and your connection is slow Inspecting step execution ... Step 1/2 : FROM ubuntu ---\u003e ea4c82dcd15a Step 2/2 : RUN apt-get update \u0026\u0026 apt-get install -y figlet \u0026\u0026 apt-get clean ---\u003e b3c08112fd1c Successfully built b3c08112fd1c Successfully tagged myfirstimage:latest A container (ea4c82dcd15a) is created from the base image The base image will be pulled, if it was not pulled before The RUN command is executed in this container The container is committed into an image (b3c08112fd1c) The build container (ea4c82dcd15a) is removed The output of this step will be the base image for the next one … The caching system If you run the same build again, it will be instantaneous. Why?\nAfter each build step, Docker takes a snapshot Before executing a step, Docker checks if it has already built the same sequence Docker uses the exact strings defined in your Dockerfile: RUN apt-get install figlet cowsay is different from RUN apt-get install cowsay figlet RUN apt-get update is not re-executed when the mirrors are updated All steps after a modified step are re-executed since the filesystem it’s based on may have changed You can force a rebuild with docker build –no-cache …\nIf you only want to trigger a partial rebuild, e.g. run apt-get update to install the latest updates, you can use the following pattern:\nENV REFRESHED_AT 2020-03-13 RUN apt-get update If you update the value of REFRESHED_AT it will invalidate the Docker build cache of that and all the following steps, thus installing the latest updates.\nRun it Now run your image\ndocker run -ti myfirstimage You’ll find yourself inside a Bash shell in the container, execute\nfiglet hello and you will see the following output:\nroot@00f0766080ed:/# figlet hello _ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/ root@00f0766080ed:/# exit the container by executing:\nexit The CMD instruction in Dockerfile With the CMD instruction in the Dockerfile, we can define the command that is executed when a container is started.\n🤔 Can you find out which CMD instruction the ubuntu image has? You did find yourself in a shell, so the instruction must either be /usr/bin/bash or /usr/bin/sh.\nModify the previously created Dockerfile as follows:\nFROM ubuntu RUN apt-get update \u0026\u0026 \\ apt-get install -y figlet \u0026\u0026 \\ apt-get clean CMD [\"figlet\", \"hello\"] Build the image with:\ndocker build -t myfirstimagecmd . And run it:\ndocker run -ti myfirstimagecmd It directly executes the defined command and prints out\n_ _ _ | |__ ___| | | ___ | '_ \\ / _ \\ | |/ _ \\ | | | | __/ | | (_) | |_| |_|\\___|_|_|\\___/ Check out https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact for more information.\nFrontend app image build After we got to grips with the image building basics, we now want to include the source code of our frontend app in an already-built container image. To achieve this we will create a Dockerfile.\nThe base image is our php:8-apache image which we used before. The ADD command allows us to add files from our current directory to the Docker image. We use this command to add the application source code into the image.\nNote Use .dockerignore to exclude files from the Docker context being added to the container. It works the same as .gitignore: https://docs.docker.com/engine/reference/builder/#dockerignore-file In the directory containing the subdirectory php-app create a Dockerfile with the following content:\nFROM php:8-apache # Copies the php source code to the correct location ADD ./php-app/ /var/www/html/ # Install additional php extension RUN docker-php-ext-install mysqli Build the php-app image Note Stop and delete the running php-app container first. Leave the database container running. Now build the image:\ndocker build -t php-app . Run the php-app container After a succesful build, run it:\ndocker run -d --network container-basics-training --name php-app -p8080:80 php-app Now open a browser and navigate to http://localhost:8080/db.php (or in the webshell use curl http://localhost:8080/db.php). You should get a response saying “Connected successfully”.\nOptional lab Configuration should always be separate from the source code, so the database connection details must not be inside the php file db.php. Fix the code in the db.php file. According to the continuous delivery principles, we don’t want usernames and passwords in our source code. Use the PHP global variable $_ENV[\"\u003cenvironment variable name\u003e\"] to read environment variables inside the container. Challenge yourself, this time the code is hidden. Try to find the solution before looking at it.\nShow me the solution Replace the line\n$password = \"venkman\"; with\n$password = $_ENV[\"password\"]; and run the container by passing the necessary env var:\ndocker run -d --name apache-php -e password=venkman -v $(pwd)/php-app:/var/www/html php:8-apache ","categories":"","description":"","excerpt":"Dockerfile Docker can build container images by reading the …","ref":"/docs/container-basics/01-basics/01/_dockerfile/","tags":"","title":"1.3 Dockerfile"},{"body":"Often you’re going to use some kind of libraries, tools or dependencies during the build phase of your application that are not necessary during the runtime of the container. To improve security and efficiency we only include whats absolutely necessary in the image. So we often remove these dependencies in the build phase after the application itself has been built.\nIn this lab you’re going to learn how to use multistage builds and what they are good for.\nPurpose If the application is not available as a prebuilt artifact, in many cases, the application itself gets built directly during the docker build process docker build -t ...\nJava Spring Boot Gradle build Example The complete example can be found at https://github.com/appuio/example-spring-boot-helloworld .\nFROM registry.access.redhat.com/ubi9/openjdk-17 LABEL org.opencontainers.image.authors=\"midcicd@puzzle.ch\" \\ io.k8s.description=\"APPUiO Example Spring Boot App\" \\ io.k8s.display-name=\"APPUiO Spring Boot App\" \\ io.openshift.expose-services=\"8080:http\" \\ io.openshift.tags=\"springboot\" EXPOSE 8080 9000 RUN mkdir -p /tmp/src/ ADD . /tmp/src/ RUN cd /tmp/src \u0026\u0026 sh gradlew build --no-daemon RUN ln -s /tmp/src/build/libs/springboots2idemo*.jar /deployments/springboots2idemo.jar During the docker build the actual application source code is added to the context and built using the gradlew build command. Gradle in this case is only used during the build phase, since it produces a jar that is then executed with java -jar ... at execution time.\nBuild phase dependencies:\nJava Gradle Runtime phase dependencies:\nJava Multi-stage builds With multistage builds you now have the possibility to actually split these two phases, so that you can pass the built artifact from phase one into the runtime phase, without the need of installing build time dependencies in the resulting docker image. Which means that the image will be smaller and consist of less unneeded dependencies.\nRead more about Docker multi-stage builds at https://docs.docker.com/develop/develop-images/multistage-build/ Create a multi-stage build Turn the docker build from the first example (Java Spring boot https://github.com/appuio/example-spring-boot-helloworld ) into a docker multistage build. As a second image you can use registry.access.redhat.com/ubi9/openjdk-17-runtime. Try to find the solution before looking at it.\nPlease create two seperate images to see the actual size difference as well.\nShow me the solution FROM registry.access.redhat.com/ubi9/openjdk-17 AS build LABEL org.opencontainers.image.authors=\"noreply@acend.ch\" \\ io.k8s.description=\"acend example spring boot app\" \\ io.k8s.display-name=\"acend spring boot app\" \\ io.openshift.expose-services=\"8080:http\" \\ io.openshift.tags=\"springboot\" RUN mkdir -p /tmp/src/ ADD . /tmp/src/ RUN cd /tmp/src \u0026\u0026 sh gradlew build --no-daemon FROM registry.access.redhat.com/ubi9/openjdk-17-runtime EXPOSE 8080 9000 COPY --from=build /tmp/src/build/libs/springboots2idemo*.jar /deployments/springboots2idemo.jar ","categories":"","description":"","excerpt":"Often you’re going to use some kind of libraries, tools or …","ref":"/docs/container-basics/01-basics/01/_dockerfile_ms/","tags":"","title":"1.4 MultiStage Build"},{"body":"Install K8s ","categories":"","description":"","excerpt":"Install K8s ","ref":"/docs/getting-started/","tags":"","title":"Getting Started"},{"body":"Table of Contents Introduction Prerequisites Namespaces PID Namespace Network Namespace Mount Namespace Seccomp AppArmor SELinux Cgroups Additional Security Practices Conclusion Introduction In this lab, you will learn about various security mechanisms available in Docker and containers, including namespaces, seccomp, AppArmor, SELinux, and cgroups. You will also learn how containers communicate with the Linux kernel and how to secure this communication.\nPrerequisites A system with Docker installed (preferably a Linux system) Basic knowledge of Docker and Linux commands Namespaces Namespaces are one of the fundamental building blocks of container isolation. They provide isolated instances of global system resources, ensuring processes inside a container do not interfere with processes outside the container or in other containers.\nPID Namespace Theoretical Introduction: PID namespaces isolate the process ID number space, meaning that processes in different PID namespaces can have the same PID. This is essential for containers, as it allows each container to have its own init process (PID 1).\nFamous Exploits: There have been vulnerabilities related to improper handling of PID namespaces that could potentially lead to privilege escalation, such as CVE-2013-1763.\nExercise:\n# Run a container in detached mode docker run -d --name test-container nginx # Enter the container's namespace docker exec -it test-container bash # Inside the container, check the process tree ps aux # From another terminal, check the process tree on the host ps aux | grep test-container Network Namespace Theoretical Introduction: Network namespaces provide isolated network stacks, including interfaces, IP addresses, routing tables, and firewall rules. This allows each container to have its own network interfaces and IP addresses.\nFamous Exploits: Exploits can occur if containers are allowed to access the host’s network namespace improperly. For example, CVE-2020-14386 was a Linux kernel vulnerability that could allow container escape through the network namespace.\nExercise:\n# Check network interfaces on the host ip a # Enter the container's network namespace docker exec -it test-container bash # Inside the container, check network interfaces ip a Mount Namespace Theoretical Introduction: Mount namespaces isolate the set of filesystem mount points seen by processes. Changes to mounts in one namespace are not visible to other namespaces, which helps in providing file system isolation.\nFamous Exploits: Improper mount namespace configurations can lead to vulnerabilities like CVE-2014-5206, where an attacker could escape the container by exploiting mounts.\nExercise:\n# Inside the container, create a new file docker exec -it test-container touch /tmp/container-file # Check if the file is present on the host ls /var/lib/docker/containers/\u003ccontainer-id\u003e/mnt/tmp/ # It won't be there because the mount namespace is isolated Seccomp Theoretical Introduction: Seccomp (secure computing mode) is a security feature in the Linux kernel that restricts the system calls a process can make. This helps in limiting the attack surface by disallowing unnecessary or dangerous system calls.\nFamous Exploits: Seccomp has mitigated several kernel vulnerabilities, such as CVE-2014-0038, where improper system call handling could lead to privilege escalation.\nExercise:\n# Run a container with a custom seccomp profile cat \u003c\u003cEOF \u003e my-seccomp-profile.json { \"defaultAction\": \"SCMP_ACT_ERRNO\", \"syscalls\": [ { \"names\": [\"clone\", \"fork\", \"vfork\"], \"action\": \"SCMP_ACT_ALLOW\" } ] } EOF docker run --security-opt seccomp=my-seccomp-profile.json nginx AppArmor Theoretical Introduction: AppArmor (Application Armor) is a Linux security module that provides mandatory access control. It confines programs to a limited set of resources based on a specified profile.\nFamous Exploits: AppArmor has helped mitigate vulnerabilities like CVE-2016-9962, where a misconfigured profile could allow an attacker to escape the Docker container.\nExercise:\n# Check the current AppArmor profiles sudo aa-status # Run a container with a custom AppArmor profile docker run --security-opt \"apparmor=your_profile\" nginx SELinux Theoretical Introduction: SELinux (Security-Enhanced Linux) is another Linux security module providing mandatory access control. It uses security policies to define how processes and users can access resources.\nFamous Exploits: SELinux has been crucial in preventing exploits such as CVE-2017-5123, which could allow a process to gain unauthorized access to system resources.\nExercise:\n# Check the SELinux status sestatus # Run a container with a specific SELinux label docker run --security-opt label:type:your_type nginx Cgroups Theoretical Introduction: Cgroups (control groups) limit, account for, and isolate the resource usage of process groups. This includes CPU, memory, disk I/O, and network bandwidth.\nFamous Exploits: Misconfigurations in cgroups can lead to denial of service attacks, such as CVE-2014-3519, where an attacker could cause excessive resource consumption.\nExercise:\n# Run a container with limited CPU and memory docker run -d --name limited-container --cpus=\".5\" --memory=\"256m\" nginx # Check the resource usage docker stats limited-container Additional Security Practices Theoretical Introduction: In addition to the above mechanisms, there are several best practices to follow to enhance container security. These include using minimal base images, keeping images up to date, scanning images for vulnerabilities, and running containers as non-root users.\nExercise:\n# Example of running a container as a non-root user docker run -u 1000:1000 nginx Conclusion In this lab, you explored various aspects of Docker/container security, including namespaces, seccomp, AppArmor, SELinux, and cgroups. By following these practices and utilizing these tools, you can enhance the security of your containerized applications.\n","categories":"","description":"","excerpt":"Table of Contents Introduction Prerequisites Namespaces PID Namespace …","ref":"/docs/container/container/","tags":"","title":"Docker/Container Security"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":" Welcome to the Kubernetes Security Training Setup Labs Slides ","categories":"","description":"","excerpt":" Welcome to the Kubernetes Security Training Setup Labs Slides ","ref":"/","tags":"","title":"Kubernetes Security Training"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"}]